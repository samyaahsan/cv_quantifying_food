# -*- coding: utf-8 -*-
"""sobel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QY9Vhjm1s9wFUSTimOO-3MDq2rdYdLlV
"""

import cv2
from matplotlib import pyplot as plt
import numpy as np
import math

def sobel(img):
  g_X = np.matrix([[-1, 0 , 1], 
                  [-2, 0, 2], 
                  [-1, 0, 1]])
  
  g_Y = np.matrix([[-1, -2, -1], 
                  [0, 0, 0], 
                  [1, 2, 1]])
  
  [rows, cols] = np.shape(img)
  sobel_image = np.zeros(shape=(rows, cols))
  
  #rows by columns
  for i in range(rows - 2):
    for j in range(cols - 2):
      #pix_x = (g_X[0][0] * img[x-1][y-1]) + (g_X[0][1] * img[x][y-1]) + (g_X[0][2] * img[x+1][y-1]) + (g_X[1][0] * img[x-1][y]) + (g_X[1][1] * img[x][y])+ (g_X[1][2] * img[x+1][y]) + (g_X[2][0] * img[x-1][y+1]) + (g_X[2][1] * img[x][y+1]) + (g_X[2][2] * img[x+1][y+1])
      
      #iterate over a 3x3 grid, compute dot product, and sum to find g_x and g_y values
      pix_x = np.sum(np.multiply(g_X, img[i:i+3, j:j+3]))
      pix_y = np.sum(np.multiply(g_Y, img[i:i+3, j:j+3]))
      #pix_y = (g_Y[0][0] * img[x-1][y-1]) + (g_Y[0][1] * img[x][y-1]) + (g_Y[0][2] * img[x+1][y-1]) + (g_Y[1][0] * img[x-1][y]) + (g_Y[1][1] * img[x][y])+ (g_Y[1][2] * img[x+1][y]) + (g_Y[2][0] * img[x-1][y+1]) + (g_Y[2][1] * img[x][y+1]) + (g_Y[2][2] * img[x+1][y+1])
     
      #compute final gradient value: sqrt(g_x^2 + g_y^2)
      #G = math.sqrt((pix_x * pix_x) + (pix_y + pix_y))
      sobel_image[i+1, j+1] = np.sqrt((pix_x * pix_x) + (pix_y * pix_y))
      

  fig1 = plt.figure(1, figsize=(20,20))
  fig1.show()
  ax1 = fig1.add_subplot(121)
  ax1.imshow(sobel_image)



if __name__ == '__main__':
  img = cv2.imread('small_steak.jpg')
  #convert to grayscale
  img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  sobel(img_gray)